// symbol 은 new Symbol로 사용할 수 없다. 대신 Symbol을 함수로 사용해서 symbol 타입을 만들어낼 수 있다.
// 함수로 사용할 때는 Symbol , 타입으로 사용할 때는 symbol로 사용한다.
console.log(Symbol('foo')===Symbol('foo'));
// 같은 함수에 같은 인자를 넣었지만 false가 나온다. why? 새로운 객체를 생성한것이므로 본질적으로 다르다.
// symbol은 고유의 값을 만들어내는것이므로 같을수가 없다, 같은 값(설명)을 넣어도 각각 다른 값으로 할당된다.
// let id = Symbol('explain') -> explain은 어떤것에도 영향을 주지 않는 이름표 역할만을 한다.

// Ts에서는 함수로 사용할때는 Symbol, 타입으로 사용할때는 symbol 로 쓰는걸 잊지말자.

const sym = Symbol();
// const obj = {
//   sym : 'value',
// }
// obj['sym'] 
// 이렇게 그냥 obj에 sym 을 넣게되면 누구나 value에 접근 가능하므로 sym이라고 하는것을 
// symbol로 하는게 아니라 []로 감싸주게되면 'sym'으로는 접근할 수 없다. 접근을 위해서는 obj[sym]을 해줘야한다.

const obj = {
  [sym] : 'value', // 객체를 이용해서 만든경우, 대괄호를 씌어 심볼형 키를 만들 수 있다.
}
obj[sym]

// 위처럼 Symbol을 이용하면 숨김(hidden)프로퍼티를 만들 수 있다. 
// 숨김 프로퍼티는 외부코드에서 접근이 불가능하고, 값도 덮어쓸 수 없는 프로퍼티이다.
// 심볼로 만든 객체는 직접 접근만 가능하고, for~문으로 출력시 심볼은 출력되지 않는다.

// 전역 심볼 : 심볼은 이름이 같더라도 모두 별개로 취급되지만, 이름이 같은 심볼이 같은 개체를 가르키기 원할 때도 있다.
//  애플리케이션 곳곳에서 심볼"id"를 이용해 특정 프로퍼티에 접근해야한다고 가정하자.
//  전역 심볼 레지스트리 안에 심볼을 만들고 해당 심볼에 접근하면, 이름이 같은 경우 항상 동일한 심볼을 반환한다.
//  레지스트리 안에 있는 심볼을 읽거나, 새로운 심볼을 생성하려면 Symbol.for(key)를 사용하면 된다.
//  이 메서드를 호출하면 이름이 key인 심볼을 반환한다. 
//  조건이 맞는 심볼이 없으면 새로운 심볼 Symbol(key) 을 만들고 레지스트리 안에 저장한다.

// Symbol.keyFor('심볼') 을 사용하면 해당 전역 심볼의 이름을 반환한다.
// 일반 심볼에서 이름을 얻고싶으면 description 메서드를 사용하면 된다.
